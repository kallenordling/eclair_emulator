! A Gaussian process of full rank.  See [1, section 2], which gives an
! introduction to Gaussian processes.
! 
! [1] J. Quinonero and C. Rasmussen. Analysis of Some Methods for
! Reduced Rank Gaussian Process Regression, in Switching and Learning
! in Feedback Systems: European Summer School on Multi-Agent Control,
! Maynooth, Ireland, September 8-10, 2003, Revised Lectures and
! Selected Papers, Springer, 2005

module m_gp_dense
  use m_gp
  use m_util
  use m_cov_all
  use m_noise_all
  implicit none

  private
  public DenseGP, read_DenseGP

  type, extends(BaseGP) :: DenseGP
     ! covariance matrix and inverse (C is represented by Q in the
     ! notation of ref [1])
     real(dp), dimension(:,:), allocatable :: C, invC
     ! precomuted product, used in the prediction
     real(dp), dimension(:), allocatable :: invCt
   contains
     procedure log_lik
     procedure update_matrices
     procedure predict
     procedure write_out
  end type DenseGP

  interface DenseGP
     module procedure make_DenseGP
     module procedure read_DenseGP
  end interface DenseGP

contains

  subroutine alloc_DenseGP(gp, n, ntheta, dims, CovFunction, NoiseModel)
    type(DenseGP), intent(inout) :: gp
    ! n: number of observations
    ! ntheta: number of covariance hyperparameters
    ! dims: dimension of the inputs
    integer, intent(in) :: n, ntheta, dims
    class(cov_fn) :: CovFunction
    class(noise_model) :: NoiseModel
    
    allocate(real(dp) :: gp%nu(NoiseModel%nparams_required(dims)))
    allocate(real(dp) :: gp%theta(ntheta))
    allocate(real(dp) :: gp%x(n, dims))
    allocate(integer :: gp%obs_type(n))
    allocate(real(dp) :: gp%t(n))
    allocate(real(dp) :: gp%C(n,n))
    allocate(real(dp) :: gp%invC(n,n))
    allocate(real(dp) :: gp%invCt(n))
    allocate(gp%covariance, mold=CovFunction)
    allocate(gp%noise_model, mold=NoiseModel)
  end subroutine alloc_DenseGP

  function make_DenseGP(nu, theta, x, obs_type, t, CovFunction, NoiseModel) result(gp)
    type(DenseGP) :: gp
    ! noise hyperparameters
    real(dp), dimension(:), intent(in) :: nu
    ! covariance hyperparameters
    real(dp), dimension(:), intent(in) :: theta
    ! training input coordinates
    real(dp), dimension(:,:), intent(in) :: x
    ! training input observation types
    integer,  dimension(:), intent(in) :: obs_type
    ! training outputs
    real(dp), dimension(:), intent(in) :: t

    class(cov_fn) :: CovFunction
    class(noise_model) :: NoiseModel
    
    integer :: n, d
    n = size(t)
    d = size(x,2)

    if (size(theta) /= CovFunction%ntheta_required(d)) then
       print *, "size of theta does not match number of hyperparameters required by the covariance function"
       stop 1
    end if
    
    if (size(nu) /= NoiseModel%nparams_required(d)) then
       print *, "size of nu (noise params) does not match number required by the noise model"
       stop 1
    end if

    call alloc_DenseGP(gp, n, size(theta), d, CovFunction, NoiseModel)

    gp%nu = nu
    gp%theta = theta
    gp%obs_type = obs_type
    gp%t = t
    gp%x = x
    call update_matrices(gp)    
  end function make_DenseGP

  subroutine write_out(this, filename)
    class(DenseGP), intent(in) :: this
    character(len=*), intent(in) :: filename
    character(len=max_name_len) :: cov_fn_name
    character(len=max_name_len) :: noise_model_name
    integer :: u ! unit number for output

    cov_fn_name = cov_fn_to_string(this%covariance)
    noise_model_name = noise_model_to_string(this%noise_model)

    open(newunit=u, file=filename)

    write (u,'(A)') "DenseGP"
    write (u,'(I10)') size(this%t), size(this%theta), size(this%nu), size(this%x,2)
    write (u,'(A)') trim(cov_fn_name)
    write (u,'(A)') trim(noise_model_name)
    write (u,'(es24.15)') this%nu, this%theta, this%x
    write (u,'(I4)') this%obs_type
    write (u,'(es24.15)') this%C, this%invC, this%invCt

    close(u)
  end subroutine write_out

  function read_DenseGP(filename) result(gp)
    character(len=*), intent(in) :: filename
    type(DenseGP) :: gp
    integer n, ntheta, nnu, d, u
    character(len=max_name_len) :: label
    character(len=max_name_len) :: cov_fn_name
    character(len=max_name_len) :: noise_model_name
    class(cov_fn), allocatable :: CovFunction
    class(noise_model), allocatable :: NoiseModel
    open(newunit=u, file=filename)
    read (u,'(A)') label

    if (trim(label) /= "DenseGP") then
       print *, "Incompatible data file"
       stop 1
    end if

    read (u,'(I10)') n, ntheta, nnu, d

    read (u,'(A)') cov_fn_name 
    call string_to_cov_fn(cov_fn_name, CovFunction)
    if (ntheta /= CovFunction%ntheta_required(d)) then
       print *, "ntheta does not match number required by the covariance function"
       stop 1
    end if

    read (u,'(A)') noise_model_name
    call string_to_noise_model(noise_model_name, NoiseModel)
    if (nnu /= NoiseModel%nparams_required(d)) then
       print *, "size of nu (noise params) does not match number required by the noise model"
       stop 1
    end if

    call alloc_DenseGP(gp, n, ntheta, d, CovFunction, NoiseModel)
    
    read (u,'(es24.15)') gp%nu, gp%theta, & 
         gp%x
    read (u,'(I4)') gp%obs_type
    read (u,'(es24.15)') gp%C, gp%invC, gp%invCt
    close(u)
  end function read_DenseGP

  subroutine update_matrices(this)
    class(DenseGP), intent(inout) :: this
    integer :: i,j,n
    real(dp) noise
    ! always a small amount of noise to stabilize the inversion
    real(dp), parameter :: noise_stab = 1e-9_dp

    n = size(this%t)
    
    do i=1,n
       do j=1,n
          if (i.ne.j) then
             noise = 0.0_dp
          else
             noise = this%noise_model%noise(this%obs_type(i), this%nu) + noise_stab
          end if
          ! Q in ref [1] (just below eq. (7) therein)
          this%C(i,j) = this%covariance%cov(this%obs_type(i), this%obs_type(j), &
               this%x(i,:), this%x(j,:), this%theta) + noise
       end do
    end do
    
    this%invC = this%C
    call ninv(this%invC)
    this%invCt = solve(this%C, this%t)
  end subroutine update_matrices

  function predict(this, xnew, obs_type_new)
    real(dp) predict
    class(DenseGP), intent(in) :: this
    real(dp), dimension(:), intent(in) :: xnew
    integer, optional, intent(in) :: obs_type_new
    
    integer :: obs_type_new1, i
    
    real(dp), dimension(size(this%t)) :: k
    if (present(obs_type_new)) then
       obs_type_new1 = obs_type_new
    else 
       obs_type_new1 = 0
    endif

    do i=1,size(this%t)
       k(i) = this%covariance%cov(obs_type_new1,this%obs_type(i),xnew,this%x(i,:),this%theta)
    end do
    ! Predictive mean from eq. (6) in ref [1]. Here, k corresponds to
    ! k^{*} in the reference, and t to y
    predict = dot_product(k, this%invCt)
  end function predict

  function log_lik(this)
    class(DenseGP), intent(in) :: this
    real(dp) log_lik
    ! First line of eq. (8) in ref. [1]
    log_lik = -0.5_dp * (logdet(this%C) + dot_product(this%t, this%invCt))
  end function log_lik

end module m_gp_dense
